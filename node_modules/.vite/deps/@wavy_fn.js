import {
  init_main,
  main_exports
} from "./chunk-PSXXRYOC.js";
import {
  __commonJS,
  __esm,
  __export,
  __publicField,
  __toCommonJS
} from "./chunk-EWTE5DHJ.js";

// node_modules/uuid/dist/max.js
var max_default;
var init_max = __esm({
  "node_modules/uuid/dist/max.js"() {
    max_default = "ffffffff-ffff-ffff-ffff-ffffffffffff";
  }
});

// node_modules/uuid/dist/nil.js
var nil_default;
var init_nil = __esm({
  "node_modules/uuid/dist/nil.js"() {
    nil_default = "00000000-0000-0000-0000-000000000000";
  }
});

// node_modules/uuid/dist/regex.js
var regex_default;
var init_regex = __esm({
  "node_modules/uuid/dist/regex.js"() {
    regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
  }
});

// node_modules/uuid/dist/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default;
var init_validate = __esm({
  "node_modules/uuid/dist/validate.js"() {
    init_regex();
    validate_default = validate;
  }
});

// node_modules/uuid/dist/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  return Uint8Array.of((v = parseInt(uuid.slice(0, 8), 16)) >>> 24, v >>> 16 & 255, v >>> 8 & 255, v & 255, (v = parseInt(uuid.slice(9, 13), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(14, 18), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(19, 23), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255, v / 4294967296 & 255, v >>> 24 & 255, v >>> 16 & 255, v >>> 8 & 255, v & 255);
}
var parse_default;
var init_parse = __esm({
  "node_modules/uuid/dist/parse.js"() {
    init_validate();
    parse_default = parse;
  }
});

// node_modules/uuid/dist/stringify.js
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
function stringify(arr, offset = 0) {
  const uuid = unsafeStringify(arr, offset);
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var byteToHex, stringify_default;
var init_stringify = __esm({
  "node_modules/uuid/dist/stringify.js"() {
    init_validate();
    byteToHex = [];
    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).slice(1));
    }
    stringify_default = stringify;
  }
});

// node_modules/uuid/dist/rng.js
function rng() {
  if (!getRandomValues) {
    if (typeof crypto === "undefined" || !crypto.getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    getRandomValues = crypto.getRandomValues.bind(crypto);
  }
  return getRandomValues(rnds8);
}
var getRandomValues, rnds8;
var init_rng = __esm({
  "node_modules/uuid/dist/rng.js"() {
    rnds8 = new Uint8Array(16);
  }
});

// node_modules/uuid/dist/v1.js
function v1(options, buf, offset) {
  var _a;
  let bytes;
  const isV6 = (options == null ? void 0 : options._v6) ?? false;
  if (options) {
    const optionsKeys = Object.keys(options);
    if (optionsKeys.length === 1 && optionsKeys[0] === "_v6") {
      options = void 0;
    }
  }
  if (options) {
    bytes = v1Bytes(options.random ?? ((_a = options.rng) == null ? void 0 : _a.call(options)) ?? rng(), options.msecs, options.nsecs, options.clockseq, options.node, buf, offset);
  } else {
    const now = Date.now();
    const rnds = rng();
    updateV1State(_state, now, rnds);
    bytes = v1Bytes(rnds, _state.msecs, _state.nsecs, isV6 ? void 0 : _state.clockseq, isV6 ? void 0 : _state.node, buf, offset);
  }
  return buf ?? unsafeStringify(bytes);
}
function updateV1State(state, now, rnds) {
  state.msecs ?? (state.msecs = -Infinity);
  state.nsecs ?? (state.nsecs = 0);
  if (now === state.msecs) {
    state.nsecs++;
    if (state.nsecs >= 1e4) {
      state.node = void 0;
      state.nsecs = 0;
    }
  } else if (now > state.msecs) {
    state.nsecs = 0;
  } else if (now < state.msecs) {
    state.node = void 0;
  }
  if (!state.node) {
    state.node = rnds.slice(10, 16);
    state.node[0] |= 1;
    state.clockseq = (rnds[8] << 8 | rnds[9]) & 16383;
  }
  state.msecs = now;
  return state;
}
function v1Bytes(rnds, msecs, nsecs, clockseq, node, buf, offset = 0) {
  if (rnds.length < 16) {
    throw new Error("Random bytes length must be >= 16");
  }
  if (!buf) {
    buf = new Uint8Array(16);
    offset = 0;
  } else {
    if (offset < 0 || offset + 16 > buf.length) {
      throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
    }
  }
  msecs ?? (msecs = Date.now());
  nsecs ?? (nsecs = 0);
  clockseq ?? (clockseq = (rnds[8] << 8 | rnds[9]) & 16383);
  node ?? (node = rnds.slice(10, 16));
  msecs += 122192928e5;
  const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  buf[offset++] = tl >>> 24 & 255;
  buf[offset++] = tl >>> 16 & 255;
  buf[offset++] = tl >>> 8 & 255;
  buf[offset++] = tl & 255;
  const tmh = msecs / 4294967296 * 1e4 & 268435455;
  buf[offset++] = tmh >>> 8 & 255;
  buf[offset++] = tmh & 255;
  buf[offset++] = tmh >>> 24 & 15 | 16;
  buf[offset++] = tmh >>> 16 & 255;
  buf[offset++] = clockseq >>> 8 | 128;
  buf[offset++] = clockseq & 255;
  for (let n = 0; n < 6; ++n) {
    buf[offset++] = node[n];
  }
  return buf;
}
var _state, v1_default;
var init_v1 = __esm({
  "node_modules/uuid/dist/v1.js"() {
    init_rng();
    init_stringify();
    _state = {};
    v1_default = v1;
  }
});

// node_modules/uuid/dist/v1ToV6.js
function v1ToV6(uuid) {
  const v1Bytes2 = typeof uuid === "string" ? parse_default(uuid) : uuid;
  const v6Bytes = _v1ToV6(v1Bytes2);
  return typeof uuid === "string" ? unsafeStringify(v6Bytes) : v6Bytes;
}
function _v1ToV6(v1Bytes2) {
  return Uint8Array.of((v1Bytes2[6] & 15) << 4 | v1Bytes2[7] >> 4 & 15, (v1Bytes2[7] & 15) << 4 | (v1Bytes2[4] & 240) >> 4, (v1Bytes2[4] & 15) << 4 | (v1Bytes2[5] & 240) >> 4, (v1Bytes2[5] & 15) << 4 | (v1Bytes2[0] & 240) >> 4, (v1Bytes2[0] & 15) << 4 | (v1Bytes2[1] & 240) >> 4, (v1Bytes2[1] & 15) << 4 | (v1Bytes2[2] & 240) >> 4, 96 | v1Bytes2[2] & 15, v1Bytes2[3], v1Bytes2[8], v1Bytes2[9], v1Bytes2[10], v1Bytes2[11], v1Bytes2[12], v1Bytes2[13], v1Bytes2[14], v1Bytes2[15]);
}
var init_v1ToV6 = __esm({
  "node_modules/uuid/dist/v1ToV6.js"() {
    init_parse();
    init_stringify();
  }
});

// node_modules/uuid/dist/md5.js
function md5(bytes) {
  const words = uint8ToUint32(bytes);
  const md5Bytes = wordsToMd5(words, bytes.length * 8);
  return uint32ToUint8(md5Bytes);
}
function uint32ToUint8(input) {
  const bytes = new Uint8Array(input.length * 4);
  for (let i = 0; i < input.length * 4; i++) {
    bytes[i] = input[i >> 2] >>> i % 4 * 8 & 255;
  }
  return bytes;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  const xpad = new Uint32Array(getOutputLength(len)).fill(0);
  xpad.set(x);
  xpad[len >> 5] |= 128 << len % 32;
  xpad[xpad.length - 1] = len;
  x = xpad;
  let a = 1732584193;
  let b = -271733879;
  let c = -1732584194;
  let d = 271733878;
  for (let i = 0; i < x.length; i += 16) {
    const olda = a;
    const oldb = b;
    const oldc = c;
    const oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return Uint32Array.of(a, b, c, d);
}
function uint8ToUint32(input) {
  if (input.length === 0) {
    return new Uint32Array();
  }
  const output = new Uint32Array(getOutputLength(input.length * 8)).fill(0);
  for (let i = 0; i < input.length; i++) {
    output[i >> 2] |= (input[i] & 255) << i % 4 * 8;
  }
  return output;
}
function safeAdd(x, y) {
  const lsw = (x & 65535) + (y & 65535);
  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
var md5_default;
var init_md5 = __esm({
  "node_modules/uuid/dist/md5.js"() {
    md5_default = md5;
  }
});

// node_modules/uuid/dist/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = new Uint8Array(str.length);
  for (let i = 0; i < str.length; ++i) {
    bytes[i] = str.charCodeAt(i);
  }
  return bytes;
}
function v35(version2, hash, value, namespace, buf, offset) {
  const valueBytes = typeof value === "string" ? stringToBytes(value) : value;
  const namespaceBytes = typeof namespace === "string" ? parse_default(namespace) : namespace;
  if (typeof namespace === "string") {
    namespace = parse_default(namespace);
  }
  if ((namespace == null ? void 0 : namespace.length) !== 16) {
    throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
  }
  let bytes = new Uint8Array(16 + valueBytes.length);
  bytes.set(namespaceBytes);
  bytes.set(valueBytes, namespaceBytes.length);
  bytes = hash(bytes);
  bytes[6] = bytes[6] & 15 | version2;
  bytes[8] = bytes[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = bytes[i];
    }
    return buf;
  }
  return unsafeStringify(bytes);
}
var DNS, URL;
var init_v35 = __esm({
  "node_modules/uuid/dist/v35.js"() {
    init_parse();
    init_stringify();
    DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  }
});

// node_modules/uuid/dist/v3.js
function v3(value, namespace, buf, offset) {
  return v35(48, md5_default, value, namespace, buf, offset);
}
var v3_default;
var init_v3 = __esm({
  "node_modules/uuid/dist/v3.js"() {
    init_md5();
    init_v35();
    init_v35();
    v3.DNS = DNS;
    v3.URL = URL;
    v3_default = v3;
  }
});

// node_modules/uuid/dist/native.js
var randomUUID, native_default;
var init_native = __esm({
  "node_modules/uuid/dist/native.js"() {
    randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
    native_default = { randomUUID };
  }
});

// node_modules/uuid/dist/v4.js
function _v4(options, buf, offset) {
  var _a;
  options = options || {};
  const rnds = options.random ?? ((_a = options.rng) == null ? void 0 : _a.call(options)) ?? rng();
  if (rnds.length < 16) {
    throw new Error("Random bytes length must be >= 16");
  }
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    if (offset < 0 || offset + 16 > buf.length) {
      throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
    }
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  return _v4(options, buf, offset);
}
var v4_default;
var init_v4 = __esm({
  "node_modules/uuid/dist/v4.js"() {
    init_native();
    init_rng();
    init_stringify();
    v4_default = v4;
  }
});

// node_modules/uuid/dist/sha1.js
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1(bytes) {
  const K = [1518500249, 1859775393, 2400959708, 3395469782];
  const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  const newBytes = new Uint8Array(bytes.length + 1);
  newBytes.set(bytes);
  newBytes[bytes.length] = 128;
  bytes = newBytes;
  const l = bytes.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);
  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);
    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
    }
    M[i] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);
    for (let t = 0; t < 16; ++t) {
      W[t] = M[i][t];
    }
    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }
    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];
    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return Uint8Array.of(H[0] >> 24, H[0] >> 16, H[0] >> 8, H[0], H[1] >> 24, H[1] >> 16, H[1] >> 8, H[1], H[2] >> 24, H[2] >> 16, H[2] >> 8, H[2], H[3] >> 24, H[3] >> 16, H[3] >> 8, H[3], H[4] >> 24, H[4] >> 16, H[4] >> 8, H[4]);
}
var sha1_default;
var init_sha1 = __esm({
  "node_modules/uuid/dist/sha1.js"() {
    sha1_default = sha1;
  }
});

// node_modules/uuid/dist/v5.js
function v5(value, namespace, buf, offset) {
  return v35(80, sha1_default, value, namespace, buf, offset);
}
var v5_default;
var init_v5 = __esm({
  "node_modules/uuid/dist/v5.js"() {
    init_sha1();
    init_v35();
    init_v35();
    v5.DNS = DNS;
    v5.URL = URL;
    v5_default = v5;
  }
});

// node_modules/uuid/dist/v6.js
function v6(options, buf, offset) {
  options ?? (options = {});
  offset ?? (offset = 0);
  let bytes = v1_default({ ...options, _v6: true }, new Uint8Array(16));
  bytes = v1ToV6(bytes);
  if (buf) {
    for (let i = 0; i < 16; i++) {
      buf[offset + i] = bytes[i];
    }
    return buf;
  }
  return unsafeStringify(bytes);
}
var v6_default;
var init_v6 = __esm({
  "node_modules/uuid/dist/v6.js"() {
    init_stringify();
    init_v1();
    init_v1ToV6();
    v6_default = v6;
  }
});

// node_modules/uuid/dist/v6ToV1.js
function v6ToV1(uuid) {
  const v6Bytes = typeof uuid === "string" ? parse_default(uuid) : uuid;
  const v1Bytes2 = _v6ToV1(v6Bytes);
  return typeof uuid === "string" ? unsafeStringify(v1Bytes2) : v1Bytes2;
}
function _v6ToV1(v6Bytes) {
  return Uint8Array.of((v6Bytes[3] & 15) << 4 | v6Bytes[4] >> 4 & 15, (v6Bytes[4] & 15) << 4 | (v6Bytes[5] & 240) >> 4, (v6Bytes[5] & 15) << 4 | v6Bytes[6] & 15, v6Bytes[7], (v6Bytes[1] & 15) << 4 | (v6Bytes[2] & 240) >> 4, (v6Bytes[2] & 15) << 4 | (v6Bytes[3] & 240) >> 4, 16 | (v6Bytes[0] & 240) >> 4, (v6Bytes[0] & 15) << 4 | (v6Bytes[1] & 240) >> 4, v6Bytes[8], v6Bytes[9], v6Bytes[10], v6Bytes[11], v6Bytes[12], v6Bytes[13], v6Bytes[14], v6Bytes[15]);
}
var init_v6ToV1 = __esm({
  "node_modules/uuid/dist/v6ToV1.js"() {
    init_parse();
    init_stringify();
  }
});

// node_modules/uuid/dist/v7.js
function v7(options, buf, offset) {
  var _a;
  let bytes;
  if (options) {
    bytes = v7Bytes(options.random ?? ((_a = options.rng) == null ? void 0 : _a.call(options)) ?? rng(), options.msecs, options.seq, buf, offset);
  } else {
    const now = Date.now();
    const rnds = rng();
    updateV7State(_state2, now, rnds);
    bytes = v7Bytes(rnds, _state2.msecs, _state2.seq, buf, offset);
  }
  return buf ?? unsafeStringify(bytes);
}
function updateV7State(state, now, rnds) {
  state.msecs ?? (state.msecs = -Infinity);
  state.seq ?? (state.seq = 0);
  if (now > state.msecs) {
    state.seq = rnds[6] << 23 | rnds[7] << 16 | rnds[8] << 8 | rnds[9];
    state.msecs = now;
  } else {
    state.seq = state.seq + 1 | 0;
    if (state.seq === 0) {
      state.msecs++;
    }
  }
  return state;
}
function v7Bytes(rnds, msecs, seq, buf, offset = 0) {
  if (rnds.length < 16) {
    throw new Error("Random bytes length must be >= 16");
  }
  if (!buf) {
    buf = new Uint8Array(16);
    offset = 0;
  } else {
    if (offset < 0 || offset + 16 > buf.length) {
      throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
    }
  }
  msecs ?? (msecs = Date.now());
  seq ?? (seq = rnds[6] * 127 << 24 | rnds[7] << 16 | rnds[8] << 8 | rnds[9]);
  buf[offset++] = msecs / 1099511627776 & 255;
  buf[offset++] = msecs / 4294967296 & 255;
  buf[offset++] = msecs / 16777216 & 255;
  buf[offset++] = msecs / 65536 & 255;
  buf[offset++] = msecs / 256 & 255;
  buf[offset++] = msecs & 255;
  buf[offset++] = 112 | seq >>> 28 & 15;
  buf[offset++] = seq >>> 20 & 255;
  buf[offset++] = 128 | seq >>> 14 & 63;
  buf[offset++] = seq >>> 6 & 255;
  buf[offset++] = seq << 2 & 255 | rnds[10] & 3;
  buf[offset++] = rnds[11];
  buf[offset++] = rnds[12];
  buf[offset++] = rnds[13];
  buf[offset++] = rnds[14];
  buf[offset++] = rnds[15];
  return buf;
}
var _state2, v7_default;
var init_v7 = __esm({
  "node_modules/uuid/dist/v7.js"() {
    init_rng();
    init_stringify();
    _state2 = {};
    v7_default = v7;
  }
});

// node_modules/uuid/dist/version.js
function version(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  return parseInt(uuid.slice(14, 15), 16);
}
var version_default;
var init_version = __esm({
  "node_modules/uuid/dist/version.js"() {
    init_validate();
    version_default = version;
  }
});

// node_modules/uuid/dist/index.js
var dist_exports = {};
__export(dist_exports, {
  MAX: () => max_default,
  NIL: () => nil_default,
  parse: () => parse_default,
  stringify: () => stringify_default,
  v1: () => v1_default,
  v1ToV6: () => v1ToV6,
  v3: () => v3_default,
  v4: () => v4_default,
  v5: () => v5_default,
  v6: () => v6_default,
  v6ToV1: () => v6ToV1,
  v7: () => v7_default,
  validate: () => validate_default,
  version: () => version_default
});
var init_dist = __esm({
  "node_modules/uuid/dist/index.js"() {
    init_max();
    init_nil();
    init_parse();
    init_stringify();
    init_v1();
    init_v1ToV6();
    init_v3();
    init_v4();
    init_v5();
    init_v6();
    init_v6ToV1();
    init_v7();
    init_validate();
    init_version();
  }
});

// browser-external:console
var require_console = __commonJS({
  "browser-external:console"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "console" has been externalized for browser compatibility. Cannot access "console.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/@wavy/fn/dist/main.cjs
var require_main = __commonJS({
  "node_modules/@wavy/fn/dist/main.cjs"(exports, module) {
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var main_exports2 = {};
    __export2(main_exports2, {
      addArticle: () => addArticle,
      arrayWithConst: () => arrayWithConst,
      asyncRun: () => asyncRun,
      averageOf: () => averageOf,
      blankSpaces: () => blankSpaces,
      buildArray: () => buildArray,
      camelCaseToLetter: () => camelCaseToLetter,
      classNameExt: () => classNameExt,
      classNameResolver: () => classNameResolver,
      coerceIn: () => coerceIn,
      copyToClipboard: () => copyToClipboard,
      count: () => count,
      dataSearcher: () => dataSearcher,
      distinct: () => distinct,
      drop: () => drop,
      dropLast: () => dropLast,
      dropLastWhile: () => dropLastWhile,
      dropWhile: () => dropWhile,
      format: () => format,
      getCaps: () => getCaps,
      getFileExt: () => getFileExt,
      getFilename: () => getFilename,
      getMimeTypes: () => getMimeTypes,
      group: () => group,
      hasIndex: () => hasIndex,
      ifDefined: () => ifDefined,
      ifEmpty: () => ifEmpty,
      inRange: () => inRange,
      indexOf: () => indexOf,
      indices: () => indices,
      inferFilename: () => inferFilename,
      insertAt: () => insertAt,
      isEmpty: () => isEmpty,
      isFile: () => isFile,
      isLetter: () => isLetter,
      isLocalFile: () => isLocalFile,
      isNumber: () => isNumber,
      lastIndex: () => lastIndex,
      map: () => map,
      mapToArray: () => mapToArray,
      maxOf: () => maxOf,
      minOf: () => minOf,
      negate: () => negate,
      ordinalIndicator: () => ordinalIndicator,
      overwrite: () => overwrite,
      pluralize: () => pluralize,
      poll: () => poll,
      random: () => random,
      range: () => range,
      readClipboardText: () => readClipboardText,
      removeAll: () => removeAll,
      repeat: () => repeat,
      run: () => run,
      sanitizeLocalFile: () => sanitizeLocalFile,
      serverDataAdapter: () => serverDataAdapter,
      someValuesEmpty: () => someValuesEmpty,
      sort: () => sort,
      strictArray: () => strictArray,
      stringToSearch: () => stringToSearch,
      subObjectList: () => subObjectList,
      sumOf: () => sumOf,
      take: () => take,
      takeLast: () => takeLast,
      takeLastWhile: () => takeLastWhile,
      takeWhile: () => takeWhile,
      timeDuration: () => timeDuration,
      toNumber: () => toNumber,
      toObject: () => ObjectConverter_default,
      trimString: () => trimString,
      undefinedIfEmpty: () => undefinedIfEmpty,
      upperFirst: () => upperFirst,
      windowed: () => windowed
    });
    module.exports = __toCommonJS2(main_exports2);
    var import_types2 = (init_main(), __toCommonJS(main_exports));
    var NumberFormatter = class _NumberFormatter {
      static format(value, format2, options) {
        switch (format2) {
          case "money":
            return _NumberFormatter.toMoney(value, options);
          default:
            return value.toLocaleString("en-us");
        }
      }
      static toMoney(amount, options) {
        const dollarSign = (options == null ? void 0 : options.excludeDollarSign) ? "" : "$";
        if (!amount) return dollarSign + ((options == null ? void 0 : options.dropDecimals) ? "0" : "0.00");
        if (options == null ? void 0 : options.truncate) {
          const strAmt = takeWhile(
            `${amount}`.split(""),
            (char) => char !== "."
          ).join("");
          const fmtMoney = (value, decimal) => {
            const getTruncatedSuffix = () => {
              if (strAmt.length <= 3) return "";
              if (range(4, 7).includes(strAmt.length)) return "k";
              if (range(7, 10).includes(strAmt.length)) return "m";
              if (range(10, 13).includes(strAmt.length)) return "b";
              if (range(13, 16).includes(strAmt.length)) return "t";
            };
            const fmtValue = parseInt(decimal) > 0 ? `${value}.${decimal}` : value;
            return dollarSign + fmtValue + getTruncatedSuffix();
          };
          if (strAmt.length <= 3) return fmtMoney(strAmt, "0");
          else {
            const relevantDigits = takeLast(
              windowed([...strAmt.split("")].reverse(), 3).map(
                (arr) => arr.reverse()
              ),
              2
            ).reverse();
            return fmtMoney(relevantDigits[0].join(""), relevantDigits[1][0]);
          }
        }
        return (amount < 0 ? "-" : (options == null ? void 0 : options.showSigns) ? "+" : "") + dollarSign + amount.toLocaleString("en-US", {
          minimumFractionDigits: (options == null ? void 0 : options.dropDecimals) ? 0 : 2,
          currency: "USD",
          currencyDisplay: "symbol",
          currencySign: "accounting",
          signDisplay: "never"
        });
      }
    };
    var NumberFormatter_default = NumberFormatter;
    var _a;
    var ObjectFormatter = (_a = class {
    }, __publicField(_a, "toString", {
      name: (name) => name ? `${name.first} ${name.last}`.trim() : "no_name",
      phoneNumber: (phoneNumber) => {
        if (!phoneNumber) return "no_phone_number";
        return `${phoneNumber.countryCode} (${phoneNumber.areaCode}) ${insertAt(
          phoneNumber.localNumber.split(""),
          3,
          "-"
        ).join("")}`;
      },
      address: (address, inline) => {
        if (address === void 0) return "no_address";
        const addressKeys = Object.keys(address).map((k) => k);
        const delimiter = (isLast) => !isLast ? "," + (!inline ? "\n" : "") : "";
        return addressKeys.map(
          (key, idx) => address[key] + delimiter(idx === lastIndex(addressKeys))
        ).join("") || "no_address";
      }
    }), _a);
    var ObjectFormatter_default = ObjectFormatter;
    var _a2;
    var InputManager = (_a2 = class {
      static separateNumbersFormatter(options = {
        numbersPerGroup: 3,
        separator: "-"
      }) {
        return {
          format: (value) => {
            let groupedValues = windowed(
              value.split(""),
              options.numbersPerGroup
            ).map((v) => v.join(""));
            if (options.groupCount) {
              groupedValues = [
                ...take(groupedValues, options.groupCount),
                drop(groupedValues, options.groupCount).join("").replace(options.separator, "")
              ].filter((v) => !isEmpty(v));
            }
            return groupedValues.join(options.separator);
          },
          unformat: (value) => {
            const unformatted = value.replaceAll(options.separator, "");
            return unformatted;
          }
        };
      }
    }, __publicField(_a2, "manualValidators", {
      percent: (value) => {
        var _a5;
        return StringFormatter_default.toNumber(value) <= 100 && run((_a5 = value.split(".")) == null ? void 0 : _a5[1], (dec) => dec ? dec.length <= 2 : true);
      }
    }), __publicField(_a2, "formatters", {
      money: {
        format: (value) => take(
          value.split(".").map(
            (sect, idx) => idx === 0 ? `${NumberFormatter_default.format(StringFormatter_default.toNumber(sect))}` : take(sect.split(""), 2).join("")
          ),
          2
        ).join("."),
        unformat: (value) => `${StringFormatter_default.toNumber(value)}`
      }
    }), _a2);
    var InputManager_default = InputManager;
    var VOWELS = "aeiouy";
    var _a3;
    var StringFormatter = (_a3 = class {
      static trimString(value, trim) {
        let newValue = value;
        while (newValue.endsWith(trim)) {
          newValue = value.split("").reverse().join("").replace(trim, "").split("").reverse().join("");
        }
        return newValue;
      }
      static pluralize(value) {
        return value[value.length - 1] === "s" ? value + "es" : value + "s";
      }
      static addArticle(value, article) {
        let fmtArticle = "";
        switch (article) {
          case "a/an":
            fmtArticle = VOWELS.includes(value == null ? void 0 : value[0].toLowerCase()) ? "An" : "A";
            break;
          default:
            return article;
        }
        return `${fmtArticle.toLowerCase()} ${value}`;
      }
      static toSearch(from) {
        return from.split("").filter((char) => char !== " ").join("").toLowerCase().trim();
      }
      static toMoney(from, options) {
        return NumberFormatter_default.toMoney(_a3.toNumber(from), options);
      }
      static toTRN(from) {
        return InputManager_default.separateNumbersFormatter().format(from);
      }
      static toNumber(value) {
        const potentialNumber = take(value.split("."), 2).join(".").split("").map(
          (char, idx) => idx === 0 && char === "-" ? char : "0123456789.".includes(char) ? char : ""
        ).join("");
        return isEmpty(potentialNumber.trim()) ? 0 : parseFloat(potentialNumber);
      }
      static upperFirst(value) {
        return value.split("").map((char, idx) => idx === 0 ? char.toUpperCase() : char).join("");
      }
    }, __publicField(_a3, "vowels", VOWELS), __publicField(_a3, "caseConverter", {
      camelToLetter: (camelCase) => {
        return camelCase.split("").map(
          (char, charIdx) => charIdx === 0 ? char.toUpperCase() : char === char.toUpperCase() && char !== char.toLowerCase() ? ` ${char}` : char
        ).join("");
      }
    }), __publicField(_a3, "extract", {
      capitalLetters: (value, count2) => {
        return value.split("", count2).filter(
          (char) => char === char.toUpperCase() && char !== char.toLowerCase()
        );
      }
    }), _a3);
    var StringFormatter_default = StringFormatter;
    var _a4;
    var TimeManager = (_a4 = class {
      format(time, format2) {
        if (!time) return "";
        const convertedDate = typeof time === "number" ? new Date(time) : time === "now" ? new Date(Date.now()) : time;
        let options = {};
        switch (format2) {
          case "hh:mm A":
            options = { hour: "numeric", minute: "2-digit" };
            break;
          case "hh:mm:ss A":
            options = { hour: "numeric", minute: "2-digit", second: "2-digit" };
            break;
          case "mm/dd/yyyy":
            options = {
              year: "numeric",
              month: "2-digit",
              day: "2-digit"
            };
            break;
          case "mm/dd/yyyy hh:mm A":
            options = {
              year: "numeric",
              month: "2-digit",
              day: "2-digit",
              hour: "numeric",
              minute: "2-digit"
            };
            break;
          default:
            options = {
              year: "numeric",
              month: format2 === "MMMM" ? "long" : "short",
              day: "numeric"
            };
            break;
        }
        const fmtDate = convertedDate.toLocaleDateString(void 0, options);
        if (format2 === "MMMM")
          return takeWhile(fmtDate.split(""), (char) => char !== " ").join("");
        if (format2 === "yyyy") return takeLast(fmtDate.split(""), 4).join("");
        if (format2 === "MMM yyyy") {
          const month = this.format(convertedDate, "MMMM");
          const year = this.format(convertedDate, "yyyy");
          return `${month} ${year}`;
        }
        if (format2 === "hh:mm A" || format2 === "hh:mm:ss A")
          return takeLastWhile(fmtDate.split(""), (char) => char !== ",").join("").trim();
        if (format2 === "MMM dd, yyyy | hh:mm A" || format2 === "MMM dd, yyyy at hh:mm A") {
          const delimiter = format2 === "MMM dd, yyyy at hh:mm A" ? "at" : "|";
          const time2 = this.format(convertedDate, "hh:mm A");
          return [fmtDate, time2].join(` ${delimiter} `);
        }
        return fmtDate;
      }
      getDuration(from, to, options) {
        const getDate = (date) => ["string", "number"].includes(typeof date) ? new Date(date === "now" ? Date.now() : date) : date;
        const difference = getDate(to).getTime() - getDate(from).getTime();
        const metrics = _a4.metrics;
        const getFmtDuration = (duration2, unit) => `${duration2} ${(options == null ? void 0 : options.abvUnits) ? unit.abv : unit.fmt}${duration2 > 1 ? "s" : ""}`;
        const getDuration = (plugins) => plugins.reduce((prev, curr) => prev / curr);
        const metric = (timeDifference = difference) => Object.keys(metrics).reduce((prev, curr) => {
          const validPrev = prev;
          const validCurr = curr;
          if (!prev) return curr;
          if (timeDifference >= metrics[validPrev].inMillis && timeDifference < metrics[validCurr].inMillis)
            return prev;
          return curr;
        });
        const duration = getDuration([difference, ...metrics[metric()].pluginVals]);
        const flooredDuration = Math.floor(duration);
        const fmtDuration = getFmtDuration(
          flooredDuration,
          flooredDuration ? metrics[metric()].unit : metrics.second.unit
        );
        if (!(options == null ? void 0 : options.disableRemainder)) {
          const remaindingDifference = difference % metrics[metric()].inMillis;
          const remaindingMetric = metrics[metric(remaindingDifference)];
          const remaindingDuration = getDuration([
            remaindingDifference,
            ...remaindingMetric.pluginVals
          ]);
          const roundedRemaindingDuration = Math.floor(remaindingDuration);
          const fmtRoundedRemaindingDuration = getFmtDuration(
            roundedRemaindingDuration,
            remaindingMetric.unit
          );
          return roundedRemaindingDuration ? `${fmtDuration} ${fmtRoundedRemaindingDuration}` : fmtDuration;
        }
        return fmtDuration;
      }
      getTimeOfDay() {
        const time = this.format("now", "hh:mm A");
        const amOrPm = takeLast(time.split(""), 2).join("");
        const hour = parseInt(
          takeWhile(time.split(""), (value) => value !== ":").join("")
        );
        return amOrPm === "am" ? "morning" : hour < 5 ? "afternoon" : "evening";
      }
    }, __publicField(_a4, "periods", {
      overview: {
        getPrevious: (period) => {
          if (period === "Today") return "Yesterday";
          if (period === "All") return "None";
          return period.replace("This", "Last");
        }
      }
    }), __publicField(_a4, "metrics", {
      second: {
        pluginVals: [1e3],
        unit: { fmt: "second", abv: "sec" },
        get inMillis() {
          return _a4.calcInMillis(this.pluginVals);
        }
      },
      get minute() {
        return {
          pluginVals: [...this.second.pluginVals, 60],
          unit: { fmt: "minute", abv: "min" },
          get inMillis() {
            return _a4.calcInMillis(this.pluginVals);
          }
        };
      },
      get hour() {
        return {
          pluginVals: [...this.minute.pluginVals, 60],
          unit: { fmt: "hour", abv: "hr" },
          get inMillis() {
            return _a4.calcInMillis(this.pluginVals);
          }
        };
      },
      get day() {
        return {
          pluginVals: [...this.hour.pluginVals, 24],
          unit: { fmt: "day", abv: "d" },
          get inMillis() {
            return _a4.calcInMillis(this.pluginVals);
          }
        };
      },
      get week() {
        return {
          pluginVals: [...this.day.pluginVals, 7],
          unit: { fmt: "week", abv: "wk" },
          get inMillis() {
            return _a4.calcInMillis(this.pluginVals);
          }
        };
      },
      get month() {
        return {
          pluginVals: [...this.day.pluginVals, 30.44],
          unit: { fmt: "month", abv: "mo" },
          inMillis: this.year.inMillis * (1 / 12)
        };
      },
      get year() {
        return {
          pluginVals: [...this.day.pluginVals, 365],
          unit: { fmt: "year", abv: "y" },
          get inMillis() {
            return _a4.calcInMillis(this.pluginVals);
          }
        };
      }
    }), __publicField(_a4, "calcInMillis", (plugins) => plugins.reduce((prev, curr) => prev * curr)), _a4);
    var TimeManager_default = TimeManager;
    var import_uuid = (init_dist(), __toCommonJS(dist_exports));
    var import_types = (init_main(), __toCommonJS(main_exports));
    var import_console = require_console();
    function fileToLocalFile(file, options) {
      var _a5, _b;
      const fileName = (_b = (_a5 = (() => {
        const fileExt = getFileExt(file.name);
        if ((options == null ? void 0 : options.filename) && options.filename.includes(fileExt))
          return options.filename;
        else if (options == null ? void 0 : options.filename) return options.filename.trim() + fileExt;
        return file.name;
      })()) == null ? void 0 : _a5.trim) == null ? void 0 : _b.call(_a5);
      const { name: _, size: __, ..._metadata } = file;
      return {
        uid: (options == null ? void 0 : options.uid) || (0, import_uuid.v4)(),
        description: options == null ? void 0 : options.description,
        path: (options == null ? void 0 : options.filepath) || (file == null ? void 0 : file.webkitRelativePath),
        typeAlias: (options == null ? void 0 : options.typeAlias) || run(
          Object.keys(import_types.LOCAL_FILE_MIME_TYPES).find(
            (key) => import_types.LOCAL_FILE_MIME_TYPES[key].includes(file.type)
          ),
          (type) => {
            if (!type) {
              (0, import_console.log)("An unknown file type was found ", file.type);
              return "unknown";
            }
            return type;
          }
        ),
        sizeInBytes: file.size,
        uploadDate: (options == null ? void 0 : options.uploadDate) === "now" ? Date.now() : (options == null ? void 0 : options.uploadDate) ?? (file == null ? void 0 : file.lastModified),
        name: fileName,
        _metadata
      };
    }
    function localFileToFile(localFile) {
      return {
        name: localFile.name,
        size: localFile.sizeInBytes,
        ...localFile._metadata
      };
    }
    var Overloader = class {
      invoke(...args) {
        if (isFile(args[0])) {
          return fileToLocalFile(...args);
        }
        if (isLocalFile(args[0])) {
          return localFileToFile(...args);
        } else throw new Error(`The arguments supplied are insufficient.`);
      }
    };
    var toObject = new Overloader().invoke;
    var ObjectConverter_default = toObject;
    var dateFormat = new TimeManager_default().format;
    var timeDuration = new TimeManager_default().getDuration;
    var upperFirst = StringFormatter_default.upperFirst;
    var camelCaseToLetter = StringFormatter_default.caseConverter.camelToLetter;
    var trimString = StringFormatter_default.trimString;
    var stringToSearch = StringFormatter_default.toSearch;
    var getCaps = StringFormatter_default.extract.capitalLetters;
    var toNumber = StringFormatter_default.toNumber;
    var addArticle = StringFormatter_default.addArticle;
    var pluralize = StringFormatter_default.pluralize;
    var objToString = ObjectFormatter_default.toString;
    var nameToString = objToString.name;
    var phoneNoToString = objToString.phoneNumber;
    var addressToString = objToString.address;
    var toMoney = (value, options) => typeof value === "string" ? StringFormatter_default.toMoney(value, options) : NumberFormatter_default.toMoney(value, options);
    function format(event, ...args) {
      const getCaller = (caller) => {
        return caller(...args);
      };
      switch (event) {
        case "date":
          return getCaller(dateFormat);
        case "address":
          return getCaller(addressToString);
        case "money":
          return getCaller(toMoney);
        case "name":
          return getCaller(nameToString);
        case "phone-number":
          return getCaller(phoneNoToString);
        default:
          return event;
      }
    }
    function sanitizeLocalFile({
      _metadata: _,
      ...file
    }) {
      return file;
    }
    function isFile(value) {
      const requiredKeys = [
        "name",
        "size",
        "type",
        "lastModified",
        "webkitRelativePath"
      ];
      if (value && typeof value === "object" && requiredKeys.every((key) => key in value))
        return true;
      return false;
    }
    function isLocalFile(value) {
      const dummyLocalFile = {
        name: "",
        description: "",
        path: "",
        sizeInBytes: 0,
        typeAlias: "unknown",
        uid: "",
        uploadDate: 0,
        _metadata: void 0
      };
      const optionalKeys = ["description"];
      const requiredKeys = Object.keys(dummyLocalFile).filter((key) => !optionalKeys.includes(key));
      const allKeys = [requiredKeys, optionalKeys].flat();
      if (value && typeof value === "object" && requiredKeys.every((key) => key in value) && Object.keys(value).every((key) => allKeys.includes(key))) {
        return true;
      }
      return false;
    }
    function getMimeTypes(typeAliases) {
      return distinct(strictArray(typeAliases)).map((alias) => import_types2.LOCAL_FILE_MIME_TYPES[alias]).flat();
    }
    function classNameResolver(baseClassName) {
      return (className) => {
        return `${baseClassName}-${className}`;
      };
    }
    function classNameExt(rootClassName) {
      return (className) => {
        return `${rootClassName} ${className}`;
      };
    }
    function range(start, end) {
      return buildArray(end - start, (i) => i + start);
    }
    function lastIndex(value) {
      return value.length - 1;
    }
    function buildArray(length, func) {
      return Array.from(Array(length)).map((_, idx) => func(idx));
    }
    function blankSpaces(count2) {
      return buildArray(count2, () => "â€Œ").join(" ");
    }
    function ordinalIndicator(amount) {
      const stringifiedAmount = `${amount}`;
      const lastIdx = lastIndex(stringifiedAmount);
      const lastChar = stringifiedAmount[lastIdx];
      const secondToLastChar = stringifiedAmount[lastIdx - 1];
      let indicator;
      if (secondToLastChar === "1") indicator = "th";
      else if (lastChar === "1") indicator = "st";
      else if (lastChar === "2") indicator = "nd";
      else if (lastChar === "3") indicator = "rd";
      else indicator = "th";
      return stringifiedAmount + indicator;
    }
    function indexOf(arr, key, value) {
      const queriedValue = arr.find((obj) => obj[key] === value);
      if (!queriedValue) return;
      return arr.indexOf(queriedValue);
    }
    function indices(arr) {
      return arr.map((_, idx) => idx);
    }
    function hasIndex(arr, index) {
      return indices(arr).includes(index);
    }
    function repeat(count2, func) {
      for (let idx = 0; idx < count2; idx++) {
        func(idx);
      }
    }
    function isLetter(value) {
      if (value.length !== 1)
        throw new Error(`Expected a single character but ${value} was provided.`);
      return /[a-zA-A]/.test(value);
    }
    function isNumber(value) {
      return !!parseFloat(value);
    }
    function count(searchFor, arrayish) {
      const fmtArr = typeof arrayish === "string" ? arrayish.split("") : arrayish;
      return fmtArr.filter((v) => v === searchFor).length;
    }
    function subObjectList(value, array) {
      const newArray = [];
      array.forEach((item) => {
        if (item[value.key] === value.value) {
          newArray.push(item);
        }
      });
      return newArray;
    }
    function random(max, min) {
      const randNum = Math.floor(Math.random() * max);
      return min !== void 0 && randNum < min ? random(max, min) : randNum;
    }
    function undefinedIfEmpty(value) {
      if (value.length > 0) return value;
    }
    function ifEmpty(value, fallback) {
      return isEmpty(value) ? fallback : value;
    }
    function windowed(arr, count2) {
      const newArr = Array.from(
        Array(Math.floor(arr.length / count2 + arr.length % count2))
      ).map(() => []);
      arr.forEach((val, idx) => {
        var _a5;
        return (_a5 = newArr[Math.floor(idx / count2)]) == null ? void 0 : _a5.push(val);
      });
      return newArr.filter((arr2) => arr2.length > 0);
    }
    function group(arr, isGroup) {
      const groups = [];
      arr.forEach((value) => {
        const groupIdx = groups.findIndex(
          (group2) => group2.every((groupVal) => isGroup(value, groupVal))
        );
        if (groupIdx !== -1) {
          groups[groupIdx].push(value);
        } else {
          groups[groups.length] = [value];
        }
      });
      return groups;
    }
    function strictArray(arr) {
      return arr.filter(
        (val) => typeof val === "string" ? val.trim().length > 0 : val !== void 0 && val !== null
      );
    }
    function maxOf(arr) {
      const fmtArr = strictArray(arr);
      return isEmpty(arr) ? 0 : fmtArr.reduce((prev, current) => current > prev ? current : prev);
    }
    function minOf(arr) {
      const fmtArr = strictArray(arr);
      return isEmpty(arr) ? 0 : fmtArr.reduce((prev, current) => current < prev ? current : prev);
    }
    function averageOf(arr) {
      const fmtArr = strictArray(arr);
      return isEmpty(fmtArr) ? 0 : sumOf(fmtArr) / fmtArr.length;
    }
    function run(value, fn) {
      return fn(value);
    }
    async function asyncRun(value, fn) {
      return fn(value);
    }
    function coerceIn(arr, min, max) {
      return arr.map((num) => num > max ? max : num < min ? min : num);
    }
    function sort(arr, sortBy, order = "asc") {
      const queryObj = (obj) => {
        const value = obj[sortBy];
        return typeof value === "string" ? value.toLowerCase() : value;
      };
      const sortOrder = (a, b) => {
        const queryA = queryObj(a);
        const queryB = queryObj(b);
        if (typeof queryA === "string") {
          const comparedQuery = queryA.localeCompare(queryB, void 0, {
            numeric: queryA.split("").some((char) => isNumber(char)),
            sensitivity: "base"
          });
          return order === "asc" ? comparedQuery === -1 : comparedQuery === 1;
        }
        return order === "asc" ? queryA < queryB : queryA > queryB;
      };
      return arr.toSorted(
        (a, b) => sortOrder(a, b) ? -1 : queryObj(a) === queryObj(b) ? 0 : 1
      );
    }
    function sumOf(value) {
      return !isEmpty(value) ? value.reduce((acc, amt) => acc + amt) : 0;
    }
    function insertAt(arr, index, value) {
      return arr.toSpliced(index, 0, value);
    }
    function overwrite(arr, index, newValue) {
      return arr.with(index, newValue);
    }
    function take(value, amount) {
      return [...value].splice(0, amount);
    }
    function takeWhile(value, fn) {
      const newValue = [];
      for (let idx = 0; idx < value.length; idx++) {
        if (!fn(value[idx], idx)) break;
        newValue.push(value[idx]);
      }
      return newValue;
    }
    function takeLast(arr, amount = 1) {
      if (amount <= 1) return [arr[arr.length - 1]];
      return [...arr].splice(arr.length - amount);
    }
    function takeLastWhile(value, fn) {
      const newValue = [];
      for (let idx = 0; idx < value.length; idx++) {
        const lastIdx = value.length - 1 - idx;
        if (!fn(value[lastIdx], lastIdx)) break;
        newValue.push(value[lastIdx]);
      }
      return newValue.reverse();
    }
    function drop(arr, count2) {
      return arr.slice(count2 || 1);
    }
    function dropWhile(arr, fn) {
      return arr.filter((v, idx) => fn(v, idx) ? false : true);
    }
    function dropLast(arr, count2 = 1) {
      return arr.slice(0, arr.length - count2);
    }
    function dropLastWhile(arr, fn) {
      return dropWhile(arr.toReversed(), fn).toReversed();
    }
    function dataSearcher(dataSource, queryProperty, searchFor, options) {
      const toSearch = (value) => stringToSearch(JSON.stringify(value)).replaceAll('"', "");
      return dataSource.filter((value) => {
        const propVal = toSearch(value[queryProperty]);
        const searcher = toSearch(searchFor);
        return (options == null ? void 0 : options.strictEquality) ? propVal === searcher : propVal.includes(searcher);
      });
    }
    function inRange(value, min, max, options) {
      if (options == null ? void 0 : options.excludeBoth) return value > min && value < max;
      if (options == null ? void 0 : options.excludeMax) return value >= min && value < max;
      if (options == null ? void 0 : options.excludeMin) return value > min && value <= max;
      return value >= min && value <= max;
    }
    function negate(condition, negate2) {
      return negate2 ? !condition : condition;
    }
    function removeAll(str, remove) {
      return str.split("").filter((char) => char !== remove).join("");
    }
    function mapToArray(map2) {
      return map2.entries().toArray().map(([key, value]) => ({ [key]: value }));
    }
    function distinct(arr) {
      const newArr = [];
      arr.forEach((value) => {
        if (!newArr.includes(value)) newArr.push(value);
      });
      return newArr;
    }
    function map(from, mappedFields) {
      return Object.fromEntries(
        Object.keys(mappedFields).map((key) => {
          const validKey = key;
          return [mappedFields[validKey], from[validKey]];
        })
      );
    }
    function isEmpty(value) {
      const valueLength = typeof value === "string" ? value.trim().length : value.length;
      return valueLength === 0;
    }
    function ifDefined(value, cb) {
      return !value ? void 0 : cb(value);
    }
    function someValuesEmpty(obj) {
      return Object.keys(obj).some((key) => isEmpty(obj[key]));
    }
    async function poll(getValue, interval = 100) {
      while (true) {
        const value = await getValue();
        if (value !== void 0) {
          return value;
        }
        await new Promise((resolve) => setTimeout(resolve, interval));
      }
    }
    function inferFilename(filePath) {
      return takeLastWhile(
        filePath.split(""),
        (char) => !"/\\".includes(char)
      ).join("");
    }
    function getFileExt(filePath) {
      return "." + takeLastWhile(filePath.split(""), (v) => v !== ".").join("");
    }
    function getFilename(params) {
      if (!params.filename) return inferFilename(params.filePath);
      const fileExt = getFileExt(params.filePath);
      if (params.filename.includes(fileExt)) return params.filename.trim();
      return params.filename.trim() + fileExt;
    }
    async function copyToClipboard(text) {
      try {
        await navigator.clipboard.writeText(text);
        return { response: "success" };
      } catch (err) {
        console.error("Failed to copy text: ", err);
        if (err instanceof Error) {
          return {
            error: {
              errorCode: "UNKNOWN",
              title: err.name,
              message: err.message
            }
          };
        }
        return {
          error: {
            errorCode: "UNKNOWN",
            title: "Failed to copy text",
            message: JSON.stringify(err)
          }
        };
      }
    }
    async function readClipboardText() {
      try {
        const text = await navigator.clipboard.readText();
        return { response: { text: text.trim() } };
      } catch (err) {
        console.error("Failed to read clipboard contents: ", err);
        return {
          error: {
            errorCode: "UNKNOWN",
            title: "Failed to read clipboard contents",
            message: `Something went wrong while trying to read the clipboard contents. [CAUSE]: ${JSON.stringify(
              err
            )}.`
          }
        };
      }
    }
    function arrayWithConst(array) {
      return { value: array, asConst: [...array] };
    }
    var import_types3 = (init_main(), __toCommonJS(main_exports));
    var iiKeys = Object.keys({
      name: null,
      address: null,
      phoneNumber: null
    });
    var stringArrayIdPrefix = "listOf";
    var multiDimArrayIdPrefix = "2DListOf";
    var multiDimArrayDelim = ":";
    var DELIMITERS = {
      name: " ",
      address: "|",
      phoneNumber: " ",
      stringArray: " "
    };
    var INDEX_MAPPER = {
      name: { first: 0, last: 1 },
      address: {
        streetAddress: 0,
        city: 1,
        parish: 2,
        country: 3
      },
      phoneNumber: {
        countryCode: 0,
        areaCode: 1,
        localNumber: 2
      }
    };
    function zip(data) {
      const stringifiedData = JSON.stringify(data);
      const errorMessage = `Failed to execute [${zip.name}].`;
      return JSON.parse(stringifiedData, (key, value) => {
        if (iiKeys.includes(key)) {
          const validKey = key;
          const handleTypeMismatchError = (required) => {
            if (typeof required !== typeof value) {
              throw new Error(errorMessage, {
                cause: `[Type Mismatch] Property type {${key}:${JSON.stringify(
                  required
                )}} is required, but {${key}:${JSON.stringify(
                  value
                )}} was provided.`
              });
            }
          };
          switch (validKey) {
            case "name":
              handleTypeMismatchError({ first: "", last: "" });
              break;
            case "address":
              handleTypeMismatchError({
                streetAddress: "",
                city: "",
                parish: "",
                country: "Jamaica"
              });
              break;
            case "phoneNumber":
              handleTypeMismatchError({
                countryCode: "1",
                areaCode: "876",
                localNumber: ""
              });
              break;
            default:
              return validKey;
          }
          let group2 = [];
          Object.keys(INDEX_MAPPER[validKey]).forEach((prop) => {
            var _a5, _b;
            const validProp = prop;
            group2[INDEX_MAPPER[validKey][validProp]] = ((_b = (_a5 = value[validProp]) == null ? void 0 : _a5.trim) == null ? void 0 : _b.call(_a5)) || "";
          });
          return group2.join(DELIMITERS[validKey]).trim();
        }
        const valueIsArray = Array.isArray(value);
        const hasArrayId = key.includes(stringArrayIdPrefix);
        if (hasArrayId && valueIsArray && strictArray(value).every((v) => typeof v === "string")) {
          return strictArray(value).join(DELIMITERS.stringArray).trim();
        } else if (hasArrayId) {
          throw new Error(errorMessage, {
            cause: `[Type Mismatch] Every property with the ${stringArrayIdPrefix} prefix, must be an array of strings. However {${key}:${value}} was provided.`
          });
        }
        const hasMultiDimArrayId = key.includes(multiDimArrayIdPrefix);
        if (hasMultiDimArrayId && valueIsArray && key.includes(multiDimArrayDelim) && value.every(
          (d) => Array.isArray(d) && d.every((sv) => typeof sv === "object")
        )) {
          const mapName = key.split(multiDimArrayDelim)[1];
          return strictArray(value).map(
            (objArr) => strictArray(objArr).map((obj) => {
              if (mapName in obj) {
                const mapValue = obj[mapName];
                if (typeof mapValue !== "string") {
                  throw new Error(errorMessage, {
                    cause: `[Type Mismatch] Expected {${mapName}:string} but {${mapName}:${mapValue}} was provided.`
                  });
                }
                return mapValue;
              } else
                throw new Error(errorMessage, {
                  cause: `[Type Mismatch] Every object in the multi dimensional array must have a property with the name ${mapName}. However ${obj} doesn't adhere to this rule.`
                });
            }).join(DELIMITERS.stringArray)
          );
        } else if (hasMultiDimArrayId && valueIsArray) {
          return value.map((arr) => {
            if (!arr.every((d) => typeof d === "string")) {
              throw new Error(errorMessage, {
                cause: `[Type Mismatch] Every sub type of the array must be a string. However ${arr} doesn't comply with this rule.`
              });
            }
            return arr.join(DELIMITERS.stringArray);
          });
        } else if (hasMultiDimArrayId) {
          throw new Error(errorMessage, {
            cause: `[Type Mismatch] Every property with the ${multiDimArrayIdPrefix} prefix, must be a multi dimensional array of strings. However {${key}:${value}} was provided.`
          });
        }
        if (typeof value === "string") return value.trim();
        return value;
      });
    }
    function unzip(data) {
      const stringifiedData = JSON.stringify(data);
      const errorMessage = `Failed to execute [${unzip.name}]`;
      return JSON.parse(stringifiedData, (key, value) => {
        var _a5;
        const isIIKey = iiKeys.includes(key);
        if (isIIKey && typeof value === "string") {
          const validKey = key;
          const splitProp = value.split(DELIMITERS[validKey]);
          return Object.fromEntries(
            Object.entries(INDEX_MAPPER[validKey]).map(([mapperKey, idx]) => {
              var _a6, _b;
              return [mapperKey, ((_b = (_a6 = splitProp[idx]) == null ? void 0 : _a6.trim) == null ? void 0 : _b.call(_a6)) || ""];
            })
          );
        } else if (isIIKey) {
          throw new Error(errorMessage, {
            cause: `[Type Mismatch] {${key}:string} expected, but {${key}:${value}} was provided.`
          });
        }
        const hasArrayId = key.includes(stringArrayIdPrefix);
        if (hasArrayId && typeof value === "string") {
          return strictArray(value.split(DELIMITERS.stringArray));
        } else if (hasArrayId) {
          throw new Error(errorMessage, {
            cause: `[Type Mismatch] {${key}:string} is required but {${key}:${value}} was provided.`
          });
        }
        const hasMultiDimArrayId = key.includes(multiDimArrayIdPrefix);
        if (hasMultiDimArrayId && Array.isArray(value)) {
          const mapName = (_a5 = key.split(multiDimArrayDelim)) == null ? void 0 : _a5[1];
          return strictArray(value).map((delimString) => {
            const splitStr = strictArray(delimString.split(DELIMITERS.stringArray));
            if (!splitStr.every((d) => typeof d === "string"))
              throw new Error(errorMessage, {
                cause: `[Type Mismatch] Expected string[] but found ${splitStr}.`
              });
            if (mapName) return splitStr.map((value2) => ({ [mapName]: value2 }));
            return splitStr;
          });
        } else if (hasMultiDimArrayId) {
          throw new Error(errorMessage, {
            cause: `[Type Mismatch] {${key}:string[]} is required but {${key}:${value}} was provided.`
          });
        }
        return value;
      });
    }
    var EVENTS = ["zip", "unzip"];
    var ServerDataAdapter = class {
      invoke(event, data) {
        switch (event) {
          case "unzip":
            return unzip(data);
          case "zip":
            return zip(data);
          default:
            event;
            throw new Error(
              `"${event}" is an unrecognized event. Try again using one of the following events ${EVENTS}.`
            );
        }
      }
    };
    var serverDataAdapter = new ServerDataAdapter().invoke;
  }
});
export default require_main();
//# sourceMappingURL=@wavy_fn.js.map
